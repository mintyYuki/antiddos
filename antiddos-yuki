#!/usr/bin/env bash
# Script is written to protect Linux servers.
# Enjoy! Made by yuki with love <3.

# --------------------------------

# Check where's the script located.
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Import the functions file.
source "$script_dir/functions.sh"

# ----------------------------------
# Call the accidental start prevention function.
accidental_start_prevention

rootcheck "$@"

# Distribution check.

# Check for the --skip_distro_check argument.
if [ "$1" != "--skip-distro-check" ]; then
    # Check the distribution
    if command -v lsb_release > /dev/null 2>&1; then
        distro=$(lsb_release -is)
    elif [ -e /etc/os-release ]; then
        distro=$(awk -F= '/^ID=/{print tolower($2)}' /etc/os-release)
    else
        print_error "Failed to determine the distribution. Make sure lsb-release is installed or /etc/os-release is accessible. If you're sure this is an error, use --skip-distro-check."
        exit 1
    fi

    case "$distro" in
        "Ubuntu" | "Debian")
            # The distribution is supported, no output.
            ;;
        *)
            print_error "Your distribution ($distro) is not supported. If you're sure this is a mistake, use --skip-distro-check and report it by opening an issue on GitHub."
            exit 1
            ;;
    esac
fi

# Check if all dependencies are installed.

dependencies=("nftables" "xtables-addons-common" "git")
missing_dependencies=()
for dep in "${dependencies[@]}"; do
    if ! dpkg -s "$dep" &>/dev/null; then
        missing_dependencies+=("$dep")
    fi
done

# If there are missing dependencies, prompt the user to install them.
if [ "${#missing_dependencies[@]}" -gt 0 ]; then
    print_warning "The following dependencies are missing: ${missing_dependencies[*]}"

    # Check if user has sudo privileges.
    if sudo -v >/dev/null 2>&1; then
        print_default2 "Do you want to install them with sudo? (y/n)"

        read -r install_response
        case "$install_response" in
            [yY])
                # Install missing dependencies.
                apt install "${missing_dependencies[@]}" -y
                ;;
            [nN])
                print_warning "The script cannot run without them. Exiting..."
                exit 1
                ;;
            *)
                print_error "Incorrect answer. Please respond with 'y' or 'n'."
                exit 1
                ;;
        esac
    else
        print_warning "Cannot find sudo. Please install the following dependencies manually:"
        for dep in "${missing_dependencies[@]}"; do
            echo "  - $dep"
        done
        exit 1
    fi
fi

# Various checks of the config file.
config_file="$script_dir/config.sh"
github_repo="https://raw.githubusercontent.com/yuk1c/antiddos/beta"

check_config() {
    if [ ! -f "$config_file" ]; then
        print_error "No config file found. Attempting to download it from GitHub..."

        if wget -q "$github_repo/$config_file" -O "$config_file"; then
            print_success "The config file was downloaded. Script will be restarted automatically."
        else
            print_error "Unable to load the config file from GitHub. Please check your internet connectivity and GitHub availability."
            exit 1
        fi
    fi

    if [ ! -r "$config_file" ]; then
        print_error "$config_file is not readable. Please check file permissions."
        exit 1
    fi

    if [ ! -s "$config_file" ]; then
        print_error "$config_file is empty. Restore it from the repository."
        exit 1
    fi
}

check_config

# Parse script arguments.
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --skip-update-check) SKIP_UPDATE_CHECK=true; shift ;;
        *) print_error "Unknown parameter passed: $1"; exit 1 ;;
    esac
done

# If --skip_update_check is not present, check for updates.
if [ "$SKIP_UPDATE_CHECK" != "true" ]; then
    # Go to the script's directory
    cd "$script_dir" || print_error "Cannot cd."

    # Fetch updates from the remote repository.
    git fetch

    # Compare local branch with the remote branch.
    if [ "$(git rev-parse HEAD)" != "$(git rev-parse @"{u}")" ]; then
        print_default "Updates available. Do you want to upgrade the script to continue? (y/n)"

        read -r response
        case "$response" in
            [yY])
                # Attempt to pull updates, handle errors quietly.
                if ! git pull -q origin beta; then
                    print_error "Unable to update script. You can skip the update check with the '--skip-update-check' argument if you think this is an mistake."
                    exit 1
                fi

                print_success "Script updated. Restarting..."
                exec "$script_dir/$(basename "$0")" "$@"    # Restart the updated script with the original arguments.
                exit 0  # Make sure to exit after the exec command.
                ;;

            [nN])
                print_default "You chose not to update. This isn't really recommended, so we exit, but there is a --skip-update-check' argument to override this."
                exit 1
                ;;
            *)
                print_error "Incorrect answer."
                exit 1
                ;;
        esac
    fi
fi

# --------------------------------

# Connect the config file.
source "$script_dir/config.sh"

# Flush all rules and add the 'yuki-script' table.
 "$nft" flush ruleset
 "$nft" add table yuki-script
 "$nft" add chain ip yuki-script prerouting '{ type filter hook prerouting priority -200; policy drop; }'

# Allow the local interface and prevent spoofing at the same time.
 "$nft" add rule ip yuki-script prerouting iif "lo" ip saddr 127.0.0.0/8 accept
 "$nft" add rule ip yuki-script prerouting ip saddr '{ 127.0.0.0/8, 0.0.0.0/8 }' iif != "lo" log prefix \"[yuki-script] Possible Spoofing: \" level debug limit rate 13/minute counter drop

# Allow established and related connections.
 "$nft" add rule ip yuki-script prerouting ct state established,related counter accept

# Allow SSH. You can implement whitelisting here. There's a template below.
# "$nft" add rule ip yuki-script prerouting ip saddr 192.168.1.0/24 tcp dport "$SSH" accept
 "$nft" add rule ip yuki-script prerouting tcp dport "$SSH" counter accept

# If you need to allow a protocol, use this template:
# "$nft" add rule ip yuki-script input ip protocol <protocol> accept
# Can be anything from /etc/protocols.

# --------------------------------
# Basic ruleset.

# Combat some TCP flood attacks by applying rate-limits.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags syn limit rate over "$SPL" log prefix \"[yuki-script] Possible SYN Flood: \" level debug limit rate 13/minute counter drop
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags syn,ack limit rate over "$SAPL" log prefix \"[yuki-script] Possible SYN-ACK Flood: \" level debug limit rate 13/minute counter drop
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags rst,ack limit rate over "$RPL" log prefix \"[yuki-script] Possible RST-ACK Flood: \" level debug limit rate 13/minute counter drop

# Allow only legitimate TCP flags and flags combinations.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags ack counter accept
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags fin,ack counter accept
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags psh,ack counter accept
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags urg,ack counter accept

# Mitigate UDP Floods with a ratelimit.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol udp meter udp-flood-limit '{ ip saddr limit rate over 3200/second }' log prefix \"[yuki-script] Possible UDP Flood: \" level debug limit rate 13/minute counter drop

# ICMP type whitelisting with state tracking and rate-limiting.
# ================================================================
 "$nft" add rule ip yuki-script prerouting icmp type echo-request limit rate 2/second ct state new counter accept # State: New
 "$nft" add rule ip yuki-script prerouting icmp type parameter-problem limit rate 15/minute ct state related counter accept # State: Related
 "$nft" add rule ip yuki-script prerouting icmp type '{ echo-reply, timestamp-reply, address-mask-reply }' limit rate 15/minute ct state established counter accept # State: Established
 "$nft" add rule ip yuki-script prerouting icmp type '{ destination-unreachable, time-exceeded }' limit rate 2/second ct state related,established counter accept # State: Related, Established

# Drop SYN packets with source-port <1024 to prevent some attacks.
# ================================================================
 "$nft" add rule ip yuki-script prerouting tcp sport != 1024-65535 tcp flags syn / fin,syn,rst,ack log prefix \"[yuki-script] Invalid TCP SYN Source port: \" level debug limit rate 13/minute counter drop

# Drop all packets with bad states.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ct state invalid,untracked log prefix \"[yuki-script] Bad packet state: \" level debug limit rate 13/minute counter drop

# Limit connection establishing rate and total connections per each IP address to mitigate attacks like "Socket/Handshake/Slowloris".
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol tcp ct state new limit rate 5/second log prefix \"[yuki-script] Connection rate-limit triggered: \" level debug limit rate 13/minute counter drop
 "$nft" add set ip yuki-script connlimit0 '{ type ipv4_addr; flags dynamic; }'
 "$nft" add rule ip yuki-script prerouting ip protocol tcp add @connlimit0 '{ ip saddr ct count over 16 }' log prefix \"[yuki-script] Connection limit triggered: \" level debug limit rate 13/minute counter drop

# Stateful TCP filtering.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags ! syn ct state new log prefix \"[yuki-script] TCP != SYN but state NEW: \" level debug limit rate 13/minute counter drop
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp flags syn ct state ! new log prefix \"[yuki-script] TCP SYN but state != NEW: \" level debug limit rate 13/minute counter drop

# Perform MSS checking for each TCP packet.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip protocol tcp tcp option maxseg size != 536-1460 log prefix \"[yuki-script] Invalid MSS value: \" level debug limit rate 13/minute counter drop

# Drop packets with weird TTL values. [beta]
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip ttl != 1-128 log prefix \"[yuki-script] Invalid TTL: \" level debug limit rate 13/minute counter drop

# Drop fragmented packets.
# ================================================================
 "$nft" add rule ip yuki-script prerouting ip frag-off '& 0x1fff' != 0 log prefix \"[yuki-script] Fragmented packet dropped: \" level debug limit rate 13/minute counter drop

# Advanced ruleset.
# Not recommended to use until it's fully converted to nftables.
# ================================================================

#################
# Generic rules #
#################

# Filtering by TCP options.
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 1 -j DROP (NOP/RFC9293)
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 3 -j DROP (WinScale/RFC7372)
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 5 -j DROP (SACK/RFC2018)
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 8 -j DROP (Timestamps/RFC7323)
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 27 -j DROP (QuickStartResp/RFC7882)
# "$IP" -t raw -A PREROUTING -p tcp --tcp-option 34 -j DROP (TFO Cookie)

# Filtering by ECN bits.
# Note: These packets are also legitimate. (ece/cwr)
# "$IP" -t raw -A PREROUTING -p tcp -m ecn --ecn-tcp-ece -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m ecn --ecn-tcp-cwr -j DROP

# Prevent SQL Injection attempts. These rules are need to be configured if you want to use them.
# "$IP" -t raw -I PREROUTING -p tcp --dport 3306 -m string --string "union select" --algo bm -j DROP
# "$IP" -t raw -I PREROUTING -p tcp --dport 3306 -m string --string "information_schema" --algo bm -j DROP

# Block HTTP 1.1 packets received on non-HTTP port(s). (common attack pattern)
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string ! --string "HTTP/1.1 OK" --algo kmp -j DROP

# Block malformed DNS Flood.
# These rules are tested well, and can be used if you experience a lot of DNS amplification attacks.
# "$IP" -t raw -A PREROUTING -p udp --sport 53 -m string --string "Refused" --algo bm -j DROP
# "$IP" -t raw -A PREROUTING -p udp --sport 53 -m string --string "0000000000000000" --algo bm -j DROP
# "$IP" -t raw -A PREROUTING -p udp --sport 53 -m string --hex-string "|3000300030003000300030003000300030003000300030003000|" --algo bm -j DROP

# Prevent NTP Reflection attacks by blocking incoming NTP Reflection packets received on the default NTP server port.
# This rule isn't checked.
# "$IP" -t raw -A PREROUTING -p udp --dport 123 -m u32 --u32 "0>>22&0x3C@8&0xFF" -j DROP

# SourcePort;ProtocolFilter against some attacks.
# The last rule may cause problems with apt.
# These rules are recommended for a better protection, but you need to test them well.
# "$IP" -t raw -A PREROUTING -p udp --sport 53 -m string ! --string "DNS" --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p udp --sport 123 -m string ! --string "NTP" --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp --sport 80 -m string ! --string "HTTP" --algo kmp -j DROP

# Patch some random attack.
# "$IP" -t raw -A PReROUTING -p tcp --syn -m u32 --u32 "0>>22&0x3C@12>>26&0x3F=0" -j DROP

# SYN/ACK Reflection mitigation.
# Optimization tip: comment the default rule that limits SYN-ACK when using these.
# "$IP" -t mangle -A PREROUTING -p tcp --syn -m recent --name blacklist --set -j DROP
# "$IP" -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,ACK -m recent --name blacklist --rcheck --seconds 60 --hitcount 10 -j DROP

# Drop ACK-PSH Packets that do not contain any data.
# Shouldn't cause problems because these packets aren't legitimate.
# "$IP" -t raw -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -m u32 --u32 "0>>22&0x3C@12=0" -j DROP

# [BETA] Drop TFO (TCP Fast Open) Packets. (SYN with data)
# "$IP" -t raw -A PREROUTING -p tcp --syn -m u32 --u32 "12&0xFFFF=0x0" -j DROP

# Length filter. Allows only packets with correct length.
# The two first rules are configured for 1500
# Maximum is 1500, but you can have 9000 MTU - and in this case, you should set 9000 as the maximum value.
# "$IP" -t raw -A PREROUTING -p tcp -m length ! --length 40:1500 -j DROP
# "$IP" -t raw -A PREROUTING -p udp -m length ! --length 20:1500 -j DROP
# "$IP" -t raw -A PREROUTING -p icmp -m length ! --length 64:72 -j DROP

##################
# OpenVPN Shield #
##################

# Whitelisting.
# "$IP" -t raw -I PREROUTING -p <tcp/udp> --dport 1194 ! -s <trusted_ip> -j DROP

# 'Application-layer' filter. (UDP)
# "$IP" -t mangle -A PREROUTING -p udp --dport 1194 --match bpf --bytecode "16,48 0 0 0,84 0 0 240,21 0 12 64,48 0 0 9,21 0 10 17,40 0 0 6,69 8 0 8191,177 0 0 0,80 0 0 8,21 0 5 56,64 0 0 17,21 0 3 1,72 0 0 4,21 0 1 62,6 0 0 65535,6 0 0 0" -m conntrack --ctstate NEW -m hashlimit --hashlimit-upto 1/second --hashlimit-burst 1 --hashlimit-mode srcip --hashlimit-name accept-openvpn -j ACCEPT

# Flow limiter. Limits the number of 'flows' - or conn-track entries.
# "$IP" -t mangle -A PREROUTING -p udp --dport 1194 -m connlimit --connlimit-above 2 -j DROP

##############
# SSH Shield #
##############

# Protection against 'socket methods'.
# "$IP" -t mangle -A PREROUTING -p tcp --dport "$SSH" -m connlimit --connlimit-above 3 -j REJECT

###############
# HTTP Shield #
###############

# Connlimit-based protection for HTTP/HTTPS server(s).
# "$IP" -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j DROP
# "$IP" -A INPUT -p tcp --dport 443 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j DROP

# User-agent filtering.
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'python-requests' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'benchmark' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'MD5(' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'censys' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'inspect' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'scanner' --algo kmp -j DROP
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --dports "$HTTP" -m string --string 'shodan' --algo kmp -j DROP

# Drop SSL packets.
# SSL is obsolete, use TLS instead.
# "$IP" -A INPUT -p tcp --dport 443 -m string --string "SSL" --algo bm -j DROP

# Drop "trace" HTTP method packets.
# Already blocked by most http-webservers.
# "$IP" -A INPUT -p tcp --dport 80 -m string --string "TRACE" --algo bm -j DROP

######################
# AntiSpoofing rules #
######################

# Block IPv4 options.
# "$IP" -t raw -A PREROUTING -m ipv4options --ssrr -j DROP
# "$IP" -t raw -A PREROUTING -m ipv4options --lsrr -j DROP
# "$IP" -t raw -A PREROUTING -m ipv4options --rr -j DROP
# "$IP" -t raw -A PREROUTING -m ipv4options --ts -j DROP
# "$IP" -t raw -A PREROUTING -m ipv4options --ra -j DROP

# Advanced AntiSpoofing [NOT RECOMMENDED]
# "$IP" -A INPUT -p all ! -d <ip_of_your_server> -j DROP

###############
# Other rules #
###############

# Drop SIP server scans.
# "$IP" -A INPUT -p udp --dport 5060 -m string --string "sipvicious" --algo bm -j DROP
# "$IP" -A INPUT -p udp --dport 5060 -m string --string "friendly-scanner" --algo bm -j DROP

# Drop SMTP packets with malicious payload.
# "$IP" -t raw -A PREROUTING -p tcp --dport 25 -m string --string "HELO" --algo bm --to 65535 -j DROP
# "$IP" -t raw -A PREROUTING -p tcp --dport 25 -m string --string "EHLO" --algo bm --to 65535 -j DROP

# Drop packets of BitTorrent amplification.
# "$IP" -t raw -A PREROUTING -m string --string "Torrent" --algo bm -j DROP

# Drop FTP packets with malicious payload.
# "$IP" -t raw -A PREROUTING -p tcp --dport 21 -m string --string "SITE EXEC" --algo bm -j DROP

# Drop DNS recursion/zone transfer operations packets.
# "$IP" -t raw -A PREROUTING -p udp --dport 53 -m string --string "recursion" --algo bm -j DROP
# "$IP" -t raw -A PREROUTING -p tcp --dport 53 -m string --hex-string "|0d 0a 0d 0a|" --algo bm -j DROP

# Geo blocking (in this rule, we block China, for example).
# "$IP" -t raw -I PREROUTING -m geoip --src-cc CN -j DROP

# Drop packets sent to DNS/NTP port but which are not related to those protocols.
# You can make multiple rules like that.
# "$IP" -t raw -A PREROUTING -p udp --dport 53 -m udp -m string ! --string "DNS" --algo bm --to 65535 -j ACCEPT
# "$IP" -t raw -A PREROUTING -p udp --dport 123 -m udp -m string ! --string "NTP" --algo bm --to 65535 -j ACCEPT

# Block heartbleed (1) / shellshock (2) attacks.
# "$IP" -t raw -A PREROUTING -p tcp --dport 443 -m u32 --u32 "52=0x18030000 && 56=0x00000000" -j DROP
# "$IP" -t raw -A PREROUTING -p tcp --dport 80 -m string --algo bm --string '() {' -j DROP

# Proxy with iptables. (example: redirect TCP packets from 25565 to your home 25500)
# "$IP" -t nat -A PREROUTING -i eth0 -p tcp --dport 25565 -j DNAT --to-destination your_home_ip:25500
# "$IP" -t nat -A POSTROUTING -o eth0 -p tcp --dport 25565 -d your_home_ip -j SNAT --to-source your_server_ext_IP

# Another patch against some weird attacks.
# "$IP" -t raw -A PREROUTING -p icmp --icmp-type 3/4 -j DROP

# Block all protocols except TCP.
# VERY Not recommended! Shouldn't be used always.
# "$IP" -A INPUT ! -p tcp -j DROP

# Limit ARP packets per MAC address.
# Needs testing.
# arptables -A INPUT --limit-rate 3/s --limit-burst 5 -j ACCEPT

# TCP Ratelimit (All flags).
# Using this rule may make other TCP rate limits redundant or conflicting.
# "$IP" -t raw -A PREROUTING -p tcp -m hashlimit --hashlimit-name tcp --hashlimit-mode srcip --hashlimit --hashlimit-above 10000/s -j DROP

# Block some unusual attacks by blocking zero TTL.
# "$IP" -t raw -A PREROUTING -m ttl --ttl-eq 0 -j DROP

# Block source-ports 0, 1 because they don't serve a legitimate purpose.
# "$IP" -t raw -A PREROUTING -p tcp -m multiport --sports 0,1 -j DROP
# "$IP" -t raw -A PREROUTING -p udp -m multiport --sports 0,1 -j DROP

# ACK & ACK-PSH Limits (against most TCP bypasses).
# Note: these rules can impact legitimate traffic due to their strict nature.
# "$IP" -t raw -A PREROUTING -p tcp --tcp-flags ACK ACK -m hashlimit --hashlimit-mode srcip --hashlimit-name ackflood --hashlimit-above 1000/s --hashlimit-burst 2 -j DROP
# "$IP" -t raw -A PREROUTING -p tcp --tcp-flags ACK,PSH ACK,PSH -m hashlimit --hashlimit-mode srcip --hashlimit-name ackpshflood --hashlimit-above 1000/s --hashlimit-burst 2 -j DROP

# Block STUN by source-port or string. You can combine them into one rule or use together.
# "$IP" -t raw -A PREROUTING -p udp --sport 3478 -j DROP
# "$IP" -t raw -A PREROUTING -p udp -m string --string "STUN" --algo kmp -j DROP

# Limit connection establishing speed. (per source IP) (we don't use --rsource because it is already set by default)
# Limiting upto 30 SYN_RECV per 5 seconds from each new IP.
# "$IP" -t raw -A PREROUTING -p tcp --syn -m conntrack --ctstate NEW -m recent --set
# "$IP" -t raw -A PREROUTING -p tcp --syn -m conntrack --ctstate NEW -m recent --update --rcheck --rttl --seconds 5 --hitcount 30

# Filtering by source IP address routing type.
# It wasn't tested a lot and can do nothing.
# "$IP" -t mangle -A PREROUTING -m addrtype --src-type UNREACHABLE -j DROP
# "$IP" -t mangle -A PREROUTING -m addrtype --src-type BLACKHOLE -j DROP
# "$IP" -t mangle -A PREROUTING -m addrtype --src-type MULTICAST -j DROP
# "$IP" -t mangle -A PREROUTING -m addrtype --src-type THROW -j DROP

# Filtering by conntrack status.
# Drops the packet if it has no known conntrack status.
# "$IP" -t mangle -A PREROUTING -p all -m conntrack --ctstatus NONE -j DROP

# --------------------------------

# The rules below actually drop packets:
 "$nft" add rule ip yuki-script prerouting log prefix \"[yuki-script] Dropped by the generic drop rule: \" level debug limit rate 13/minute counter drop
 "$nft" add rule ip yuki-script prerouting ip protocol tcp log prefix \"[yuki-script] Dropped by the generic TCP drop rule: \" level debug limit rate 13/minute counter drop

# Sysctl.conf tweaks.
# --------------------------------

# Backup management.
# Note: the backups are located in /etc/sysctl_backups.
# After you uninstall the script, they aren't deleted and are still kept there.

# If the backup directory does not exist, create it.
# If cannot create it - show aa error and exit.
if [ ! -d "$backup_dir" ]; then
    if ! mkdir -p "$backup_dir"; then
        print_error "Cannot create backup directory: $backup_dir" >&2
        exit 1
    fi
fi

# Make a backup of the sysctl.conf.
# If cannot create it - show an error and exit.
if ! cp "$sysctl_conf" "$backup_file"; then
    print_error "Failed to create backup." >&2
    exit 1
fi

# Scan for old backup files, and delete them, if needed.
# If cannot delete them - show an error and exit.
if [ "$num_backups" -gt "$max_backups" ]; then
    if ! find "$backup_dir" -maxdepth 1 -type f -printf '%T@ %p\n' | sort -k1,1n | head -n -"$max_backups" | cut -d' ' -f2- | xargs -I {} rm "{}"; then
        print_error "Failed to remove old backups." >&2
        exit 1
    fi
fi

# Apply the tweaked sysctl.conf file.

echo -e "
#
# Modified sysctl.conf by https://github.com/yuk1c/antiddos [beta]
#

# Reverse-Path filtering, aka Spoof protection.
# 0 = Disabled, 1 = Strict, 2 = Loose
# You need to comment these parameters if you're using an asymmetric routing.
# ================================================================
 net.ipv4.conf.default.rp_filter = 1    # For all new interfaces
 net.ipv4.conf.all.rp_filter = 1        # For all current interfaces

# Always-on syncookies.
# You don't need this (!) unless you're being fried by a SYN Flood.
# ================================================================
# net.ipv4.tcp_syncookies = 2

# Do less SYN/SYN-ACK retries.
# If you like to do experiments, you can try to set 1/1.
# ================================================================
 net.ipv4.tcp_synack_retries = 2
 net.ipv4.tcp_syn_retries = 2

# Don't accept new connections if the TCP backlog is full.
# Lowers the CPU load if someone is attacking your server and bypassing the rules.
# ================================================================
 net.ipv4.tcp_abort_on_overflow = 1

# Increase the limit of established connections.
# High values aren't really good, BTW.
# ================================================================
 net.core.somaxconn = 8192

# Make your [TCP] network stack compliant with RFC 1337.
# Slightly improves stability and security.
# ================================================================
 net.ipv4.tcp_rfc1337 = 1

# Other tweaks.
# ================================================================
 net.netfilter.nf_conntrack_tcp_loose = 0               # Turn on strict TCP mode for conntrack.
 net.netfilter.nf_conntrack_tcp_ignore_invalid_rst = 1  # Ignore invalid RST packets.
 net.netfilter.nf_conntrack_checksum = 0                # Don't perform checksum calculations by NF. Your server's NIC is probably already doing that.
 net.ipv4.tcp_mtu_probing = 0                           # Do not use TCP MTU probing for additional security & lower CPU load. (it might not be 'the best' for overall performance. You can try these: 1 = TCP MTU Probing when an ICMP BlackHole detected, 2 = Always-on TCP MTU Probing)
 kernel.unprivileged_userns_clone = 0                   # Don't allow unprivileged user namespaces.
 net.ipv4.tcp_thin_linear_timeouts = 1                  # Enable dynamic triggering of thin linear timeouts (for lower TCP retransmission latencies)
 net.ipv4.conf.all.ignore_routes_with_linkdown = 1      # Ignore [IPv4] routes via interfaces that are down. Good for additional reliability.
 net.ipv6.conf.all.ignore_routes_with_linkdown = 1      # Ignore [IPv6] routes via interfaces that are down. Good for additional reliability.
 net.ipv4.ip_local_port_range = 1024 65535              # Increase the range of source ports for less possible port conflicts.
 net.ipv4.igmp_link_local_mcast_reports = 0             # Don't send IGMP Link-Local multicast reports.
 net.ipv4.ip_autobind_reuse = 1                         # Improve performance for high network loads by reusing local ports.
 net.core.bpf_jit_harden = 1                            # BPF-JIT Hardening.
 net.ipv4.conf.all.drop_unicast_in_l2_multicast = 1     # Drop IPv4 unicast packets encapsulated in link-layer multicast/broadcast frames.
 net.ipv6.conf.all.drop_unicast_in_l2_multicast = 1     # Drop IPv6 unicast packets encapsulated in link-layer multicast/broadcast frames.
 net.ipv4.conf.all.arp_filter = 1                       # ARP Protection (filter).
 net.ipv4.conf.all.arp_ignore = 1                       # Reply to an ARP request only if the target IP address is local address configured on the incoming interface.
 net.ipv4.tcp_shrink_window = 1                         # Shrink TCP RWIN when it's necessary. Good for stability and performance.
 net.ipv4.tcp_tw_reuse = 1                              # Reuse TIME_WAIT sockets for new TCP connections. Good for performance.
 net.ipv6.icmp.echo_ignore_multicast = 1                # Ignore ICMPv6 multicast echos.
 net.ipv6.conf.all.drop_unsolicited_na = 1              # Your server received a NA packet but hasn't asked for it with a NS packet? Drop it.

# Exclusive tweaks.
# ================================================================
 kernel.io_delay_type = 0           # On newer systems, I/O delay is useless, so we can turn it off.
 vm.memfd_noexec = 1                # Don't allow execution of memory-backed files created with 'memfd_create()' (for security).
 vm.numa_stat = 0                   # Turn off NUMA statistics.
 #kernel.soft_watchdog = 0           # Turn off kernel soft-lockup detector. (for very slight performance gain)
" > /etc/sysctl.conf

echo "flush ruleset" > /etc/nftables.conf
"$nft" -o list ruleset > /etc/nftables.conf
systemctl enable --now nftables > /dev/null &
eval "$sc_reload" > /dev/null || { print_error "Cannot apply the sysctl.conf tweaks using the '"$sc_reload"' command."; exit 1; } &

print_success "All changes were applied and rules will persist across reboots."
print_default2 "\nMake sure your network works properly. For example, ping something, do 'sudo apt update', and open another SSH session (if applicable)."
print_default2 "If you have some problems = sudo systemctl disable nftables, and restart the server."
print_default2 "\nThere is a guide in the script's readme on how to allow specific ports and more cool stuff, take a look."

tput sgr0 && exit 0 # Reset the terminal color and exit.